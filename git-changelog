#!/usr/bin/python

'''Print changelog
Requires git:

 * 1.5.7 for 'git branch --contains'

'''

prog_name = "git-changelog"
prog_version = "0.2"
prog_epilog = '''
Example:
   %(prog)s --rare
   %(prog)s --trends
'''


############################################
# Imports
############################################

import logging
import argparse
import json
import os
import sys
import signal
import time
import subprocess as sp
import re

############################################
# Logging
############################################

try:
    # Module logging_conf should intialize root logger and, perhaps some
    # others, and assign 'log' variable to proper logger.
    from logging_conf import log
except:
    log = logging.getLogger()
    log.setLevel(logging.WARNING)
    # log.setLevel(logging.DEBUG)
    h = logging.StreamHandler()
    # f = MyFormatter()
    f = logging.Formatter()
    h.setFormatter(f)
    log.addHandler(h)


############################################
# Argument parsing
############################################

p = argparse.ArgumentParser(
    prog=prog_name,
    formatter_class=argparse.RawDescriptionHelpFormatter,
    description=__doc__,
    epilog=prog_epilog)
p.add_argument("--debug", help="debug mode",
               dest='debug', action="store_true")
p.add_argument("--version", action='version',
               version='%(prog)s ' + prog_version)
p.add_argument("-v", help="verbose mode",
               dest='verbose', action="store_true")


args = p.parse_args()

if args.verbose:
    log.setLevel(logging.INFO)
if args.debug:
    log.setLevel(logging.DEBUG)

log.debug("Args: %s", json.dumps(vars(args), indent=4, sort_keys=True))

############################################
# Misc
############################################

def mkdir_p(path):
    path = os.path.expanduser(path)
    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == os.errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise
    return path


def signal_handler(signal, frame):
    print
    sys.exit(1)

############################################
# Issue Provders
############################################

class Issues(object):
    def __init__(self):
        self.name = 'base'
        self.issues = {}
        self.load()

    def __str__(self):
        s = self.name + ' issues: '
        s += ', '.join(sorted(self.issues.keys()))
        return s

    def load(self):
        pass

    def close_issue(self, ino):
        try:
            self.issues[ino]['state'] = 'closed'
        except:
            pass


    def changelog(self, ref, issues):
        '''
        Returns changelog composed from closed issues among `issues`
        '''

        cmd = 'git for-each-ref --sort=taggerdate --format'.split()
        cmd += ['%(committerdate:iso8601) %(taggerdate:iso8601)', ref]
        log.debug("cmd '%s'", cmd)
        date = sp.check_output(cmd).strip().split()[:2]
        date = ' '.join(date)
        ver = '/'.join(ref.split('/')[2:])
        header = "## Version: %s\nDate: %s\n" % (ver, date)
        header += '\n'

        chlog = ''
        links = ''
        for ino in sorted(issues.keys()):
            if ino not in self.issues:
                continue
            i = self.issues[ino]
            if i['state'] != 'closed' and issues[ino]['state'] != 'closed':
                continue
            chlog += ' * [#%s] %s\n' % (i['number'], i['title'])
            links += '[#%s]: %s\n' % (i['number'], i['url'])
        if chlog:
            chlog += '\n'
        if links:
            links += '\n'
        return  header + chlog + links


class GithubIssues(Issues):
    def __init__(self, user, repo, password=None):
        self.user = user
        self.repo = repo
        self.password = password
        super(GithubIssues, self).__init__()


    def load(self):
        if self.password is None:
            print "Enter password for", self.user, "at github.com"
            print "or leave empty for unauthenticated access"
            self.password = raw_input("Password: ").strip()

        cmd = ['curl', '-s']
        if self.password:
            cmd += ['-u', self.user + ':' + self.password]

        page = 1
        url = "https://api.github.com/repos/%s/%s/issues" % \
              (self.user, self.repo)
        while True:
            if page > 5:
                break
            purl = url + '?state=all&per_page=30&page=' + str(page)
            pcmd = cmd + [purl]
            log.debug("cmd '%s'", pcmd)
            text = sp.check_output(pcmd)
            try:
                issues = json.loads(text)
            except:
                break
            if not isinstance(issues, list) or len(issues) == 0:
                break
            for i in issues:
                no = str(i['number'])
                ni = {
                    'number': no,
                    'title': i['title'],
                    'state': i['state'],
                    'url': i['html_url']
                }
                self.issues[no] = ni
            page += 1



############################################
# Main
############################################

def time_line():

    tl = []

    # root commit
    cmd = 'git rev-list --max-parents=0 HEAD'.split()
    log.debug("cmd '%s'", cmd)
    root = sp.check_output(cmd).strip()
    log.debug("root '%s'", root)
    tl.append(root)

    # current branch
    cmd = 'git rev-parse --symbolic-full-name HEAD'.split()
    log.debug("cmd '%s'", cmd)
    branch_ref = sp.check_output(cmd).strip()
    branch = branch_ref.split('refs/heads/')[1]
    log.debug("branch '%s'", branch)

    # tags
    cmd = 'git for-each-ref --sort=taggerdate --format'.split()
    cmd += ['%(refname) %(taggerdate:iso8601)', 'refs/tags']
    log.debug("cmd '%s'", cmd)
    tags = sp.check_output(cmd).strip().splitlines()
    ntags = []
    for tag in tags:
        # log.debug("tag '%s'", tag)
        tag = tag.split()
        log.debug("tag '%s'", tag[0])
        cmd = 'git branch --contains'.split()
        cmd += [tag[0]]
        # log.debug("cmd '%s'", cmd)
        bs = sp.check_output(cmd).strip().splitlines()
        for i, t in enumerate(bs):
            t = t.strip()
            if t.startswith('* '):
                t = t[2:]
            bs[i] = t
        log.debug("bs '%s'", bs)
        if branch in bs:
            tl.append(tag[0])
            log.debug("tag '%s' reachable from '%s'", tag[0], branch)
        else:
            log.debug("tag '%s' unreachable from '%s'", tag[0], branch)

    tl.append(branch_ref)
    log.debug("tl %s", json.dumps(tl, indent=4))
    return tl


def get_refed_issues(from_, to_):

    closed = [
        'close', 'closes', 'closed',
        'fix', 'fixes', 'fixed',
        'resolve', 'resolves', 'resolved'
    ]

    data = {
        'issues': {}
    }
    regs = ['#(?P<num>\d+)\W', '\Wgh-(?P<num2>\d+)\W']
    regs = ['(%s)' % r for r in regs]
    reg = '(?P<act>\w+\s+)?' + '|'.join(regs)
    reg = re.compile(reg)

    def start_start(line):
        # log.debug("enter")
        data['state'] = "start"

    def start_cont(line):
        # log.debug("enter")
        if line.startswith("commit "):
            commit_start(line)

    def commit_start(line):
        # log.debug("enter")
        data['state'] = "commit"
        data['commit'] = line.split()[1]
        header_start(line)

    def commit_cont(line):
        # log.debug("enter")
        pass

    def body_start(line):
        # log.debug("enter")
        data['state'] = "body"

    def body_cont(line):
        # log.debug("enter")
        # log.debug("body: '%s'", line)
        if line.startswith("commit "):
            # end_start()
            commit_start(line)
            return
        if not line:
            return
        if not line[0].isspace():
            return
        for m in reg.finditer(line):
            issue = m.group('num')
            if not issue:
                issue = m.group('num2')
            if not issue:
                continue
            act = m.group('act')
            if act is None:
                act = ''
            else:
                act = act.strip()
            if act in closed:
                state = "closed"
            else:
                state = "open"
            log.debug("issue %s act '%s'", issue, state)
            if issue not in data['issues']:
                i = {
                    "number": issue,
                    "state": state
                }
                data['issues'][issue] = i
            elif state == "closed":
                data['issues'][issue]['state'] = 'closed'


    def header_start(line):
        # log.debug("enter")
        data['state'] = "header"

    def header_cont(line):
        # log.debug("enter")
        if line == '':
            body_start(line)

    # log.info("log: %s vs %s", from_, to_)
    cmd = 'git log --pretty=medium'.split()
    cmd += [ from_ + '..' + to_]
    log.debug("cmd '%s'", cmd)
    proc = sp.Popen(cmd, stdout=sp.PIPE)
    start_start('')
    while True:
        line = proc.stdout.readline()
        llen = len(line)
        line = line.rstrip()
        # log.debug("line: state %s, chars %d, '%s'", data['state'], llen, line)
        if llen == 0:
            break
        if data['state'] == "start":
            start_cont(line)
        elif data['state'] == "header":
            header_cont(line)
        elif data['state'] == "body":
            body_cont(line)
        else:
            pass

    log.debug("issues %s\n%s", to_, json.dumps(data['issues'], indent=4))
    return data['issues']


def get_all_issues():
    cmd = 'git remote -v'.split()
    log.debug("cmd '%s'", cmd)
    origins = sp.check_output(cmd).splitlines()
    for line in origins:
        origin = line.split()[1]
        if origin.startswith('https://github.com/'):
            origin = origin.split('/')
            user = origin[3]
            repo = origin[4]
            if repo.endswith(".git"):
                repo = repo[:-4]
            return GithubIssues(user, repo)
    return Issues()


def main():
    signal.signal(signal.SIGINT, signal_handler)

    aii = get_all_issues()
    log.debug("%s", aii)
    tl = time_line()

    tl.reverse()
    chlog = []
    while len(tl) > 1:
        ii = get_refed_issues(tl[1], tl[0])
        print aii.changelog(tl[0], ii)
        del tl[0]


if __name__ == '__main__':
    main()
