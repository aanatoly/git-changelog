#!/usr/bin/python

'''Print changelog
Requires git:

 * 1.5.7 for 'git branch --contains'

'''

prog_name = "git-changelog"
prog_version = "0.1"
prog_epilog = '''
Example:
   %(prog)s --rare
   %(prog)s --trends
'''


############################################
# Imports
############################################

import logging
import argparse
import json
import os
import sys
import signal
import time
import subprocess as sp
import re

############################################
# Logging
############################################

try:
    # Module logging_conf should intialize root logger and, perhaps some
    # others, and assign 'log' variable to proper logger.
    from logging_conf import log
except:
    log = logging.getLogger()
    log.setLevel(logging.WARNING)
    # log.setLevel(logging.DEBUG)
    h = logging.StreamHandler()
    # f = MyFormatter()
    f = logging.Formatter()
    h.setFormatter(f)
    log.addHandler(h)


############################################
# Argument parsing
############################################

p = argparse.ArgumentParser(
    prog=prog_name,
    formatter_class=argparse.RawDescriptionHelpFormatter,
    description=__doc__,
    epilog=prog_epilog)
p.add_argument("--debug", help="debug mode",
               dest='debug', action="store_true")
p.add_argument("--version", action='version',
               version='%(prog)s ' + prog_version)
p.add_argument("-v", help="verbose mode",
               dest='verbose', action="store_true")

p.add_argument("-n", help="Search first N shows only",
               metavar='N', dest="limit", type=int, default=30)
p.add_argument("--scan-rare",
               help="Scan rare (default: %(default)s)",
               choices=['yes', 'no'], default='no')
p.add_argument("--scan-watchlist",
               help="Scan watchlist (default: %(default)s)",
               choices=['yes', 'no'], default='yes')
p.add_argument("--scan-local",
               help="Scan local torrents (default: %(default)s)",
               choices=['yes', 'no'], default='yes')
p.add_argument("--search-kat",
               help="Search KickAss Torrents (default: %(default)s)",
               choices=['yes', 'no'], default='yes')
p.add_argument("--search-air-dates",
               help="Search Air Dates (default: %(default)s)",
               choices=['yes', 'no'], default='yes')
p.add_argument("--search-status",
               help="Search IsMyShowCancelled (default: %(default)s)",
               choices=['yes', 'no'], default='no')
p.add_argument("--search-trends",
               help="Search KAT for trends (default: %(default)s)",
               choices=['yes', 'no'], default='no')
p.add_argument("--rare", help="Show rare shows",
               dest='rare', action="store_true")
p.add_argument("--trends", help="Show trends",
               dest='trends', action="store_true")
p.add_argument("name",
               help="Show name",
               nargs='?')

args = p.parse_args()

if args.verbose:
    log.setLevel(logging.INFO)
if args.debug:
    log.setLevel(logging.DEBUG)

log.debug("Args: %s", json.dumps(vars(args), indent=4, sort_keys=True))

############################################
# Misc
############################################

def mkdir_p(path):
    path = os.path.expanduser(path)
    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == os.errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise
    return path


def signal_handler(signal, frame):
    print
    sys.exit(1)


############################################
# Main
############################################

def time_line():

    tl = []

    # root commit
    cmd = 'git rev-list --max-parents=0 HEAD'.split()
    log.debug("cmd '%s'", cmd)
    root = sp.check_output(cmd).strip()
    log.debug("root '%s'", root)
    tl.append(root)

    # current branch
    cmd = 'git rev-parse --symbolic-full-name HEAD'.split()
    log.debug("cmd '%s'", cmd)
    branch_ref = sp.check_output(cmd).strip()
    branch = branch_ref.split('refs/heads/')[1]
    log.debug("branch '%s'", branch)

    # tags
    cmd = 'git for-each-ref --sort=taggerdate --format'.split()
    cmd += ['%(refname) %(taggerdate:iso8601)', 'refs/tags']
    log.debug("cmd '%s'", cmd)
    tags = sp.check_output(cmd).strip().splitlines()
    ntags = []
    for tag in tags:
        # log.debug("tag '%s'", tag)
        tag = tag.split()
        log.debug("tag '%s'", tag[0])
        cmd = 'git branch --contains'.split()
        cmd += [tag[0]]
        # log.debug("cmd '%s'", cmd)
        bs = sp.check_output(cmd).strip().splitlines()
        for i, t in enumerate(bs):
            t = t.strip()
            if t.startswith('* '):
                t = t[2:]
            bs[i] = t
        log.debug("bs '%s'", bs)
        if branch in bs:
            tl.append(tag[0])
            log.debug("tag '%s' reachable from '%s'", tag[0], branch)
        else:
            log.debug("tag '%s' unreachable from '%s'", tag[0], branch)

    tl.append(branch_ref)
    log.debug("tl %s", json.dumps(tl, indent=4))
    return tl

def get_refed_issues(from_, to_):

    data = {
        'issues': []
    }
    regs = ['#(?P<num>\d+)\W', '\Wgh-(?P<num2>\d+)\W']
    regs = ['(%s)' % r for r in regs]
    reg = '|'.join(regs)
    reg = re.compile(reg)

    def start_start(line):
        # log.debug("enter")
        data['state'] = "start"

    def start_cont(line):
        # log.debug("enter")
        if line.startswith("commit "):
            commit_start(line)

    def commit_start(line):
        # log.debug("enter")
        data['state'] = "commit"
        data['commit'] = line.split()[1]
        header_start(line)

    def commit_cont(line):
        # log.debug("enter")
        pass

    def body_start(line):
        # log.debug("enter")
        data['state'] = "body"

    def body_cont(line):
        # log.debug("enter")
        # log.debug("body: '%s'", line)
        if line.startswith("commit "):
            # end_start()
            commit_start(line)
            return
        if not line:
            return
        if not line[0].isspace():
            return
        for m in reg.finditer(line):
            issue = m.group('num')
            if not issue:
                issue = m.group('num2')
            if issue:
                # log.info("issue %s", issue)
                if issue not in data['issues']:
                    data['issues'].append(issue)

    def header_start(line):
        # log.debug("enter")
        data['state'] = "header"

    def header_cont(line):
        # log.debug("enter")
        if line == '':
            body_start(line)

    # log.info("log: %s vs %s", from_, to_)
    cmd = 'git log --pretty=medium'.split()
    cmd += [ from_ + '..' + to_]
    log.debug("cmd '%s'", cmd)
    proc = sp.Popen(cmd, stdout=sp.PIPE)
    start_start('')
    while True:
        line = proc.stdout.readline()
        llen = len(line)
        line = line.rstrip()
        # log.debug("line: state %s, chars %d, '%s'", data['state'], llen, line)
        if llen == 0:
            break
        if data['state'] == "start":
            start_cont(line)
        elif data['state'] == "header":
            header_cont(line)
        elif data['state'] == "body":
            body_cont(line)
        else:
            pass
    return data['issues']


def get_all_github_issues_debug(origin):
    try:
        ii = json.loads(open('github.json', 'r').read())
        return ii
    except Exception as e:
        print "================\n", e
        return []


def get_all_github_issues_real(origin):
    origin = origin.split('/')
    owner = origin[3]
    repo = origin[4]
    if repo.endswith(".git"):
        repo = repo[:-4]
    print "Fetch issues from", '/'.join(origin)
    print "Enter password, or leave empty for unauthenticated access"
    password = raw_input("Password: ").strip()
    log.debug("gihub: owner %s, repo %s, password '%s'",
              owner, repo, password)

    ii = []
    page=1
    cmd = ['curl', '-s']
    if password:
        cmd += ['-u', owner + ':' + password]
    url = "https://api.github.com/repos/%s/%s/issues" % (owner, repo)
    while True:
        if page > 5:
            break
        purl = url + '?state=closed&per_page=30&page=' + str(page)
        pcmd = cmd + [purl]
        log.debug("cmd '%s'", pcmd)
        text = sp.check_output(pcmd)
        try:
            i = json.loads(text)
        except:
            break
        if not isinstance(i, list) or len(i) == 0:
            break
        ii += i
        page += 1

    return ii


def get_all_github_issues(origin):
    lii = []
    if args.debug:
        lii = get_all_github_issues_debug(origin)
        # log.debug("debug lii %s", json.dumps(lii, indent=4))
    if not lii:
        lii = get_all_github_issues_real(origin)
        # log.debug("real lii %s", json.dumps(lii, indent=4))
    if args.debug:
        open('github.json', 'w').write(json.dumps(lii, indent=4))
    aii = {}
    for i in lii:
        no = str(i['number'])
        if no not in aii:
            aii[no] = {}
            for k in ['html_url', 'state', 'title', 'number']:
                aii[no][k] = i[k]

    return aii

def get_all_issues():
    cmd = 'git remote -v'.split()
    log.debug("cmd '%s'", cmd)
    origins = sp.check_output(cmd).splitlines()
    for line in origins:
        origin = line.split()[1]
        if origin.startswith('https://github.com/'):
            return get_all_github_issues(origin)
    return {}


def print_ref(ref, ii, aii):
    log.debug("ref %s", ref)
    cmd = 'git for-each-ref --sort=taggerdate --format'.split()
    cmd += ['%(committerdate:iso8601) %(taggerdate:iso8601)', ref]
    log.debug("cmd '%s'", cmd)
    date = sp.check_output(cmd).strip().split()[:2]
    date = ' '.join(date)
    ver = '/'.join(ref.split('/')[2:])
    s = "## Version: %s\nDate: %s\n" % (ver, date)
    s += '\n'
    if not ii:
        return s

    links = ''
    for no in ii:
        log.debug("no '%s', %s, known %s", no, type(no), (no in aii.keys()))
        if no in aii.keys():
            i = aii[no]
            # s += ' * [#%s][#%s] %s\n' % (i['number'], i['number'], i['title'])
            s += ' * [#%s] %s\n' % (i['number'], i['title'])
            links += '[#%s]: %s\n' % (i['number'], i['html_url'])
        else:
            s += ' * #%s\n' % no
    s += '\n'
    s += links
    return s


def main():
    signal.signal(signal.SIGINT, signal_handler)
    tl = time_line()
    tl.reverse()
    chlog = []
    while len(tl) > 1:
        ii = get_refed_issues(tl[1], tl[0])
        chlog.append([tl[0], ii])
        del tl[0]

    aii = get_all_issues()
    log.debug("aii %s", json.dumps(aii, indent=4))
    for c in chlog:
        s = print_ref(c[0], c[1], aii)
        print s


if __name__ == '__main__':
    main()
